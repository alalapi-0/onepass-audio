"""Audition 标记写出工具。"""
from __future__ import annotations

import csv
from pathlib import Path
from typing import Mapping, Sequence

HEADER = ["Name", "Start", "End", "Duration", "Comment", "Type"]


def format_marker_seconds(value: float) -> str:
    """以 Audition 期望的小数形式格式化秒数。"""

    return f"{max(0.0, float(value)):.3f}"


def _coerce_row(row: Mapping[str, object]) -> dict[str, str]:
    start = row.get("Start", row.get("start", 0.0))
    end = row.get("End", row.get("end"))
    duration = row.get("Duration", row.get("duration"))
    if duration is None and end is not None and start is not None:
        try:
            duration = float(end) - float(start)
        except (TypeError, ValueError):
            duration = 0.0
    name = row.get("Name", row.get("name", ""))
    marker_type = row.get("Type", row.get("type", "cue"))
    comment = row.get("Comment", row.get("Description", row.get("description", row.get("text", ""))))
    try:
        start_value = float(start)
    except (TypeError, ValueError):
        start_value = 0.0
    try:
        duration_value = float(duration)
    except (TypeError, ValueError):
        duration_value = 0.0
    end_value = start_value + max(0.0, duration_value)
    return {
        "Name": str(name or ""),
        "Start": format_marker_seconds(start_value),
        "End": format_marker_seconds(end_value),
        "Duration": format_marker_seconds(max(0.0, duration_value)),
        "Comment": str(comment or ""),
        "Type": str(marker_type or "cue"),
    }


def write_audition_csv(
    csv_path: Path,
    rows: Sequence[Mapping[str, object]] | None,
    *,
    total_duration: float | None = None,
    fallback_description: str | None = None,
) -> Path:
    """写出 Audition 标记文件，并确保至少有 1 行。"""

    csv_path = csv_path.expanduser().resolve()
    csv_path.parent.mkdir(parents=True, exist_ok=True)
    normalized = [_coerce_row(row) for row in rows or []]
    if not normalized:
        duration_value = max(0.0, float(total_duration or 0.0))
        normalized.append(
            {
                "Name": "KEEP_ALL",
                "Start": format_marker_seconds(0.0),
                "End": format_marker_seconds(duration_value),
                "Duration": format_marker_seconds(duration_value),
                "Comment": fallback_description or "Generated by fallback",
                "Type": "cue",
            }
        )
    with csv_path.open("w", encoding="utf-8-sig", newline="") as fh:
        writer = csv.DictWriter(fh, fieldnames=HEADER)
        writer.writeheader()
        for row in normalized:
            payload = {key: row.get(key, "") for key in HEADER}
            if not payload.get("End"):
                try:
                    start_val = float(row.get("Start", 0.0))
                    duration_val = float(row.get("Duration", 0.0))
                except (TypeError, ValueError):
                    start_val = 0.0
                    duration_val = 0.0
                payload["End"] = format_marker_seconds(start_val + duration_val)
            writer.writerow(payload)
    return csv_path


__all__ = ["write_audition_csv", "format_marker_seconds"]
